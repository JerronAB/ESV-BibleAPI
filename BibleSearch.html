<!DOCTYPE HTML>
<html>
	<head>
		<title>Search the ESV Bible</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link
        href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/3.2.0/tailwind.min.css"
        rel="stylesheet"
    />
    <style>
    body {
        background-color: #2e2e2e; /* Soft dark gray */
        color: #ffffff; /* White text */
        font-family: Arial, Helvetica, sans-serif; /* Gentle font */
        margin: 0;
        padding: 0;
    }
    </style>
	<script>
		i = 0;
		function searchTerm() {
    const input = document.getElementById('searchInput').value;
    const searchMode = "plain_search"; // Default search mode, can be updated based on UI selection
    const searchTerms = [input]; // For plain search, just the input value
    const caseSensitive = false; // Default case sensitivity, can be updated by UI checkbox
    const trimSpaces = true; // Default trim spaces, can be updated by UI checkbox
    const radius = 5; // Default radius for assoc_search, can be updated by UI input if assoc_search is selected

    const searchRequest = {
        search_mode: searchMode,
        search_terms: searchTerms,
        general_options: {
            case_sensitive: caseSensitive,
            trim_spaces: trimSpaces
        },
        mode_options: {
            plain_search_options: {
                case_sensitive: caseSensitive // Redundant here as general_options.case_sensitive applies, but included for clarity
            },
            assoc_options: {
                radius: radius // Only relevant for "assoc_search" mode
            }
        }
    };

    searchBible(searchRequest);
}

async function searchBible(searchRequest) {
    const url = `/api/search`; // Define a consistent search endpoint on your backend

    try {
        const response = await fetch(url, {
            method: 'POST', // Use POST method to send JSON in body
            headers: {
                'Content-Type': 'application/json' // Set Content-Type to JSON
            },
            body: JSON.stringify(searchRequest) // Convert Javascript object to JSON string
        });

        if (!response.ok) {
            throw new Error(`Network response was not ok, status: ${response.status}`);
        }

        const jsonData = await response.json(); // Expecting JSON response from backend
        displayVerses(jsonData); // Pass JSON data directly to displayVerses
    } catch (error) {
        console.error('There was a problem with the fetch operation:', error);
    }
}

function displayVerses(jsonData) { // Expecting JSON array of Verse objects
    const itemsContainer = document.querySelector('.items');
    itemsContainer.innerHTML = ''; // Clear previous results
    i = 0; // Reset verse counter

    if (!jsonData || !Array.isArray(jsonData)) { // Basic check if jsonData is valid array
        console.error('Invalid JSON response format:', jsonData);
        itemsContainer.textContent = "Error: Could not display verses due to invalid response.";
        return;
    }

    jsonData.forEach(verse => {
        if (verse && verse.verse_name && verse.verse_content) { // Check if verse object and its properties are valid
            const item = document.createElement('div');
            item.className = 'inner';
            verse_id=`return_verse_${i++}`;
            item.id=verse_id;
            item.setAttribute("onclick", `expandVerse('${verse_id}')`);

            const heading = document.createElement('h3');
            heading.textContent = verse.verse_name; // Use verse.verse_name from JSON

            const paragraph = document.createElement('p');
            paragraph.textContent = verse.verse_content; // Use verse.verse_content from JSON

            item.appendChild(heading);
            item.appendChild(paragraph);
            itemsContainer.appendChild(item);
        } else {
            console.warn("Skipping invalid verse data:", verse); // Warn about invalid verse data
        }
    });
}
async function expandVerse(verse_id) {
    console.log(`Expanding ${verse_id}`);
    const verseDiv = document.getElementById(verse_id);
    const h3 = verseDiv.children[0]; // this should return our verse name
    verse_name = h3.innerText;

    // Parse verse_name to create search terms for "specified_search"
    let book_name, chapter_num, verse_num_str;
    if (verse_name.indexOf("Judges") !== -1 || verse_name.indexOf("Philippians") !== -1) {
        book_name = verse_name.substring(0, verse_name.indexOf(" ")).trim();
    } else {
        book_name = verse_name.replaceAll(" ", "").substring(0, 3).trim();
    }
    chapter_num = verse_name.substring(verse_name.lastIndexOf(" ") + 1, verse_name.indexOf(":")).trim();
    verse_num_str = verse_name.substring(verse_name.indexOf(":") + 1).trim();

    let searchTerms = [];
    if (verse_num_str.indexOf("-") !== -1) {
        const starting_verse = parseInt(verse_num_str.substring(0, verse_num_str.indexOf("-")).trim());
        const ending_verse = parseInt(verse_num_str.substring(verse_num_str.indexOf("-") + 1).trim());
        for (let v = starting_verse; v <= ending_verse; v++) {
            searchTerms.push(`${book_name} ${chapter_num}:${v}`);
        }
    } else {
        searchTerms.push(`${book_name} ${chapter_num}:${verse_num_str}`);
    }

    console.log("searchTerms for expand:", searchTerms); // Log the search terms

    const searchRequest = {
        search_mode: "specified_search", // Use "specified_search" mode for verse lookup
        search_terms: searchTerms, // Use the parsed verse name as search terms
        general_options: {
            case_sensitive: false, // Or get from UI if needed
            trim_spaces: true // Or get from UI if needed
        },
        mode_options: {
            plain_search_options: { // These options are not really used in specified_search, but included for structure
                case_sensitive: false
            },
            assoc_options: { // Not used in specified_search
                radius: 5
            }
        }
    };

    const url = `/api/search`; // Your backend search endpoint

    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(searchRequest)
        });

        if (!response.ok) {
            throw new Error(`Network response was not ok, status: ${response.status}`);
        }

        const jsonData = await response.json();

        if (!jsonData || !Array.isArray(jsonData) || jsonData.length === 0) {
            console.error('Invalid or empty JSON response for verse expansion:', jsonData);
            verseDiv.children[1].innerText = "Error: Could not load verse content."; // Update paragraph with error
            return;
        }

        const expandedVerses = jsonData; // Assuming backend returns a list of verses for specified search
        let expandedText = "";
        expandedVerses.forEach(verse => {
            if (verse && verse.verse_content && verse.verse_name) {
                expandedText += verse.verse_name + " - " + verse.verse_content + "\n\n";
            }
        });


        var p = verseDiv.children[1];
        p.innerText = expandedText.trim(); // Set the expanded text, trim to remove trailing newlines

        // Update heading to reflect potentially expanded verse range (optional - keep original for single verse lookup)
        // h3.innerText = book_name + " " + chapter_num + ":" + starting_verse + "-" + ending_verse; // Original logic - might need adjustment
        h3.innerText = verse_name; // Keep original verse name for heading for simplicity in 'expand'

    } catch (error) {
        console.error('There was a problem with the fetch operation for verse expansion:', error);
        verseDiv.children[1].innerText = "Error: Failed to load verse content."; // Update paragraph with error message
    }
}
</script>
</head>
	</head>
	<body class="is-preload">
        <div id="wrapper" class="divided">
        <section class="wrapper style1 align-center color7 invert" id="verses">
          <div class="inner">
            <h2>ESV Bible Search</h2>
			<div>
				<input type="text" id="searchInput" placeholder="Search for a term or word...">
				<button type="button" onclick="searchTerm()">Search</button>
			</div>
          </div>
        </section>
    </div>
	</body>
</html>